% !TEX root = ../vvedenie_v_go.tex
\section{Переменные}

В языке Го переменные объявляются вот так:

\begin{gocode}
var x int
\end{gocode}

или вот так:

\begin{gocode}
x := 5
\end{gocode}

То есть оператор «\,\code{=}\,»~"--- это присваивание, а оператор «\code{:=}\,»~"--- это краткое объявление переменной с одновременным присваиванием. Во втором случае тип выводится из значения\footnote{При этом любое целое число будет определено как имеющее тип int, а число с точкой в записи~"--- как float64.}.

Можно так:
\begin{gocode}
var x, y, z int
a, b, c := 1, 2, 3
\end{gocode}

\subsection{Значения по умолчанию}
Объявленные через \code{var} переменные (даже локальные) получают нулевое значение соответствующего типа. Среди компилируемых языков такой гарантией обладает почти один только Го.

\subsection{Локальные и глобальные переменные}
Переменные можно объявлять в процедурах или перед процедурами~"--- в последнем случае такие переменные глобальные.

Ещё есть такой вариант (чаще используется для объявления глобальных переменных):
\begin{gocode}
var (
  y int
  z int = 7
  x = 51
  w = int(3)
)
\end{gocode}

Помните, что глобальные переменные следует объявлять крайне редко.

\subsection{Кортежное присваивание}

В левой и правой части оператора присваивания могут находиться разделённые запятыми выражения. В этом случае присвивание происходит как бы одновременно слева направо. Запись \code{a, b = 1, 2} запишет единицу в $a$ и двойку в $b$.

\begin{gocode}
x := 5
y := 4
a, b := 2, 3
x = x + 1
x, y = a, b // то же, что и x = a; y = b
x, y = y, x // поменять местами
\end{gocode}

Последнее присваивание~"--- не то же самое, что \code{x = y; y = x}
(в этом случае потерялось бы изначальное значение $x$).

\subsection{Область видимости}
(по-английски~"--- scope)

Переменные в Го доступны в рамках того блока, где были объявлены, начиная от места их объявления и до соответствующей ближайшему блоку «\code{\}}».

То есть переменная, объявленная внутри тела оператора \code{if}, будет существовать только в соответствующей ветке.
\begin{gocode}
a, y := 1, 0
if a == 1 {
  x := 7
  y = x + a
}
fmt.Println(x) // Ошибка компиляции: x не определена
\end{gocode}

Но если переменная с тем же именем была объявлена выше, то после закрытия блока она снова станет доступна (вместе со своим старым значением).
\begin{gocode}
a, x, y := 1, 25, 0
if a == 1 {
  x := 7
  y = x + a
}
fmt.Println(x, y) // Выведет 25 8
\end{gocode}

Это называется затенением (shadowing) переменных.

В Го неиспользованная переменная вызывает ошибку компиляции.

\begin{gocode}
if a == 1 {
  x := 5 // Ошибка: переменная не используется
}
\end{gocode}

Если переменную присвоить в специальное место «\,\code{\_}\,», ошибка пропадёт.
\begin{gocode}
if a == 1 {
  x := 5
  _ = x
}
\end{gocode}

\subsection{Автоопределение типа}

Если переменная объявляется без указания типа, тип определяется автоматически на основани начального значения переменной.

\begin{gocode}
a := 5    // тип int
b := 5.0  // тип float64
c := "ы"  // тип string
d := true // тип bool
\end{gocode}

Более сложный пример: объявляем массив сразу со значениями.
Тут тип в общем-то не указан, а указано значение, но зато значение синтаксически включает в себя описание типа. Так тоже работает.
\begin{gocode}
x := [3]int{26, 92, 70}
\end{gocode}

Если, например, нужна переменная типа \code{float32} (а не \code{float64}), это можно сделать двумя способами:
\begin{gocode}
var a float32 = 4.0
b := float32(4.0)
\end{gocode}
В последней строчке используется приведение типа.

Кроме типа int есть ещё \code{int8}, \code{int16}, \code{int32}, \code{int64}, а также \code{uint8}, \code{uint16}, \code{uint32}, \code{uint64}.

Тип \code{int} фактическ соответствует типу \code{int64}, но может быть и \code{int32} на некоторых вычислительных системах. Логически, однако, тип \code{int} отделён от них обоих. Это значит, что, например, для присваивания между \code{int} \code{int64} необходимо приводить типы. Благодаря этому ограничению в Го намного меньше проблем с портированием программ на другие платформы, чем в языке Си.

Тип \code{byte}~"--- синоним \code{uint8}.

Тип \code{rune}~"--- синоним \code{int32}. Рунами в Го называются литеры (тип \code{CHAR} в Обероне).

\code{int} с приставкой \code{u} означает беззнаковое целое (unsigned integer). Диапазон значений от 0 до $2^n - 1$, где $n$~"--- число в записи типа (32 в случае \code{int32}).

Без приставки \code{u} целые числа имеют сдвинутый диапазон, чтобы поместились отрицательные числа: от $-2^{n-1}$ до $2^{n-1} - 1$.

Пример диапазона ($2^8 = 256, 2^7 = 128$):
\begin{gocode}
uint8 = 0..255
int8 = -128..127
\end{gocode}

ЦЫКЛЫ

В Го есть, якобы, только один цикл~"--- for. Но на самом деле это 5 разных циклов:
while, for (в сишном стиле), loop (бесконечный цикл), repeat until, и foreach (здесь он for range). Теперь ещё есть и for range над целочисленными значениями, что напоминает уже паскалевский цикл фор.

В циклах часто объявляют переменные. Их существование также ограничено всем оператором цикла.

Наиболее полная форма:

\begin{gocode}
for i := 0; i < 10; i++ {
  //...
}
\end{gocode}

Здесь:
i := 0~"--- инициализация
i < 10~"--- условие продолжения
i++~"--- последействие

i := 0~"--- сработает один раз перед началом цикла. Похоже на такую же штуку в ифе.

i < 10~"--- очередной шаг цикла (включая и самый первый) будет выполнен только в том случае, если перед его началом это условие истинно.

i++~"--- будет происходить всякий раз в конце каждого шага цикла.


Можно и не объявлять переменную в цикле, а сделать это заранее.

\begin{gocode}
i := 0;
for ; i < 10; i++ {
  //...
}
fmt.Println(i) // Выведет 10
\end{gocode}

Тогда переменная будет существовать (и сохранит своё приобретённое в цикле новое значение) и после цикла.

Форма типа WHILE:
\begin{gocode}
i := 0
for i < 10 {
  //...
  i++
}
\end{gocode}
В этой форме вообще нет точек с запятыми. Это просто обычный цикл WHILE.

Если точки с запятыми есть, их должно быть две:
\begin{gocode}
i := 0
// это глупость, но так можно
for ; i < 10; {
  //...
  i++
}
\end{gocode}

«Операторы инициализации и последействия можно опустить. В этом случае не нужны и точки с запятыми: сишная конструкция while в Го пишется вот как for» (Тур по Го).

\begin{gocode}
// s is a slice
s := []int{22, 0, 77, 44, 19, 123, 6, 11, 23}
for i, x := range s {
  fmt.Println(i, x)
}
\end{gocode}
i будет принимать значения 0, 1, 2, 3...

x будет принимать значения 22, 0, 77, 44...

Если что-то из этого не нужно, надо положить его в мусорник:

\begin{gocode}
for _, x := range s {
  fmt.Println(x)
}
\end{gocode}

Если нужны только индексы (i), можно так:

\begin{gocode}
for i := range s {
  fmt.Println(i)
}
\end{gocode}

\section{Задачи на практику (домашнее задание)}

\subsection{Задачи на линейные программы}

1) Вычислить квадрат, куб, четвертую и пятую степень введённого числа.
Примечание: Сэкономить~"--- не вычислять каждый раз всё заново. В этой задаче не предполагается использование if и for.

\subsection{Задачи на оператор ЕСЛИ}

2) Влазит ли кирпич в коробку. Вводятся шесть чисел: размеры кирпича и размеры коробки. Считать, что в коробку того же размера кирпич со скрипом, но помещается.

3) Високосный ли год?

Подсказка:

Формулировка критерия високосности следующая:
Число должно нацело делиться на 4, но если оно делится на 100, то оно должно также делиться и на 400.

Или, если перефразировать, получается следующее:

Чтобы считать год високосным, должны выполняться следующие условия:

1. Число должно делиться нацело на 4. Если оно не делится на 4, то год не високосный~"--- и на этом всё, остальные проверки не требуются.

2. Дальше смотрим, делится ли число на 100. Если не делится, к нему больше вопросов нет. Получается, оно делится на 4, но не на 100~"--- замечательно. Год високосный. Вопрос закрыт.

3. Однако если число-таки делится на 100, то к нему появляется следующее требование: оно должно делиться на 400.

Вот попробуйте это всё объединить в одно составное условие с операциями И (\&\&) и ИЛИ (||).

\subsection{Задачи на циклы}

4) Угадайка на диапазоне [1..100]. Человек загадывает число. Программа отгадывает его максимум за 7 шагов половинного деления.

Примечание: Машина угадывает число, задавая серию вопросов вида «Ваше число больше 50?». Человек отвечает да или нет. (В данном примере, если загадано число 50, ответ будет «нет»).

Подход к решению: Две переменные L и R задают начало и конец промежутка, в котором идёт поиск правильного ответа. Рекомендуется задавать L не включительно, R~"--- включительно. Промежуток 1..100 будет поэтому выражен как L = 0, R = 100.
Каждый шаг цикла либо L сдвигается вправо, либо R сдвигается влево. Цикл заканчивается, когда в промежутке остаётся ровно одно число~"--- оно и есть ответ.

5) Вывести все простые числа, не превосходящие N = 1000.

6) Найти сумму цифр натурального числа.

7) Вводятся числа, причём каждое следующее не меньше предыдущего. Как только введённое число окажется меньше предыдущего, ввод заканчивается (последнее введённое число не считаем членом введённой последовательности). Программа выводит:
а) сколько всего чисел введено,
б) сколько различных чисел введено,
в) каково максимальное количество повторов одного числа.
